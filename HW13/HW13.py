# Описание/Пошаговая инструкция выполнения домашнего задания:
# Реализовать хеш-таблицу, использующую метод цепочек
# Или реализовать хеш-таблицу с открытой адресацией
# дополнительно: реализовать "ленивое" удаление
# реализовать квадратичный пробинг


# создаем узел таблицы
class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None


# Создаем саму таблицу
class Hashtable:
    # Заполняем хэш таблицу элементами типа Node
    def __init__(self, size):
        self.data = [Node()] * size
        self.size = size

    # Рассчитываем хэш
    def hash(self, key, size):
        return key % size

    # Вставляем новый хэш
    def put(self, key):
        # Найдите хеш-значение вставляемых данных
        hash_value = self.hash(key, self.size)
        # Если на этой позиции нет записи, то просто вставляем:
        if self.data[hash_value].data == None:
            self.data[hash_value].data = key
        # Если на позиции уже что-то есть:
        # последовательно проверяем наличие места в связанном списке,
        # начиная с положения хеш-значения в хеш-таблице, пока на проверку не попадет пустая позиция
        else:
            # Создаем новый узел для хранения данных
            temp = Node(key)
            # p - указатель на головной узел связанного списка
            p = self.data[hash_value]
            # Проверяем связанный список
            while p.next != None:
                p = p.next
            # При выходе из цикла p указал на конец связанного списка, заполняем следующий элемент нашим значением
            p.next = temp

    # Поиск наличия определенного значения (ключа) в хеш-таблице
    def get(self, key):
        # Получить хеш-значение элемента
        hash_value = self.hash(key, self.size)
        # 1-й случай: заголовок связанного списка под хеш-значением равен ключу, указывающему на то, что он найден
        if self.data[hash_value].data == key:
            return True
        # 2-й случай: заголовок связанного списка, соответствующий хэш-значению, не является ключом
        else:
            # Вводим p - указатель на головной узел связанного списка
            p = self.data[hash_value]
            while p != None and p.data != key:
                p = p.next
            # При выходе из цикла, если p не указал на конец связанного списка, значит, элемент найден
            if p != None and p.data == key:
                return True
        # Если мы прошли по всему связанного списка, значит значения нет в хэш-таблице
        return False

    # Удалить узел, данные которого являются ключом в хэш-таблице
    def delete(self, key):
        # Если нет в таблице такого ключа, возвращаем ошибку
        if not self.get(key):
            return 'Delete Error'
        # Ищем хеш-значение, соответствующее данным
        hash_value = self.hash(key, self.size)
        # если заголовок связанного списка с этим хэш значением совпадает с данными, которые надо удалить,
        # заголовок связанного списка обнуляется
        if self.data[hash_value].data == key:
            self.data[hash_value].data = None
        else:
            # Задаем указатель на головной узел связанного списка в этой позиции
            p = self.data[hash_value]
            # Задаем указатель на узел перед текущим узлом связанного списка (изначально - пустой)
            pre = None
            # Ищем позицию для удаления, пока не нашли, обновляем p
            while p != None and p.data != key:
                pre = p
                p = p.next
            # Если конец все равно не найден, выводим ошибку
            if p == None:
                return 'Delete Error'
            else:
                pre.next = p.next

# Тестируем
print("test")
n = 10
h = Hashtable(n)
for i in range(0, n):
    h.data[i].data = i
#добавляем
h.put(68)
print("наша хэш таблица:")
for i in range(0, n):
    print(h.data[i].data)
# удаляем
print("удаляем 1")
h.delete(1)
print("удаляем 9")
h.delete(9)
#ищем
print("0:", h.get(0))
print("9:", h.get(9))

